{"version":3,"sources":["incremental-dom.js"],"names":[],"mappings":"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","file":"incremental-dom.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.IncrementalDOM = {}));\n}(this, function (exports) { 'use strict';\n\n  /**\n   * @type {TreeWalker}\n   */\n  var walker_;\n\n\n  /**\n   * @return {TreeWalker} the current TreeWalker\n   */\n  var getWalker = function() {\n    return walker_;\n  };\n\n\n  /**\n   * Sets the current TreeWalker\n   * @param {TreeWalker} walker\n   */\n  var setWalker = function(walker) {\n    walker_ = walker;\n  };\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n\n  /**\n   * Keeps track of information needed to perform diffs for a given DOM node.\n   * @param {!string} nodeName\n   * @param {?string=} key\n   * @constructor\n   */\n  function NodeData(nodeName, key) {\n    /**\n     * The attributes and their values.\n     * @const\n     */\n    this.attrs = {};\n\n    /**\n     * An array of attribute name/value pairs, used for quickly diffing the\n     * incomming attributes to see if the DOM node's attributes need to be\n     * updated.\n     * @const {Array<*>}\n     */\n    this.attrsArr = [];\n\n    /**\n     * The incoming attributes for this Node, before they are updated.\n     * @const {!Object<string, *>}\n     */\n    this.newAttrs = {};\n\n    /**\n     * The key used to identify this node, used to preserve DOM nodes when they\n     * move within their parent.\n     * @const\n     */\n    this.key = key;\n\n    /**\n     * Keeps track of children within this node by their key.\n     * {?Object<string, !Element>}\n     */\n    this.keyMap = null;\n\n    /**\n     * Whether or not the keyMap is currently valid.\n     * {boolean}\n     */\n    this.keyMapValid = true;\n\n    /**\n     * The last child to have been visited within the current pass.\n     * @type {?Node}\n     */\n    this.lastVisitedChild = null;\n\n    /**\n     * The node name for this node.\n     * @const {string}\n     */\n    this.nodeName = nodeName;\n\n    /**\n     * @type {?string}\n     */\n    this.text = null;\n  }\n\n\n  /**\n   * Initializes a NodeData object for a Node.\n   *\n   * @param {!Node} node The node to initialize data for.\n   * @param {string} nodeName The node name of node.\n   * @param {?string=} key The key that identifies the node.\n   * @return {!NodeData} The newly initialized data object\n   */\n  var initData = function(node, nodeName, key) {\n    var data = new NodeData(nodeName, key);\n    node['__incrementalDOMData'] = data;\n    return data;\n  };\n\n\n  /**\n   * Retrieves the NodeData object for a Node, creating it if necessary.\n   *\n   * @param {!Node} node The node to retrieve the data for.\n   * @return {NodeData} The NodeData for this Node.\n   */\n  var getData = function(node) {\n    var data = node['__incrementalDOMData'];\n\n    if (!data) {\n      var nodeName = node.nodeName.toLowerCase();\n      var key = null;\n\n      if (node instanceof Element) {\n        key = node.getAttribute('key');\n      }\n\n      data = initData(node, nodeName, key);\n    }\n\n    return data;\n  };\n\n  /**\n   * Applies an attribute or property to a given Element. If the value is null\n   * or undefined, it is removed from the Element. Otherwise, the value is set\n   * as an attribute.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {?(boolean|number|string)=} value The attribute's value.\n   */\n  var applyAttr = function(el, name, value) {\n    if (value == null) {\n      el.removeAttribute(name);\n    } else {\n      el.setAttribute(name, value);\n    }\n  };\n\n  /**\n   * Applies a property to a given Element.\n   * @param {!Element} el\n   * @param {string} name The property's name.\n   * @param {*} value The property's value.\n   */\n  var applyProp = function(el, name, value) {\n    el[name] = value;\n  };\n\n\n  /**\n   * Applies a style to an Element. No vendor prefix expansion is done for\n   * property names/values.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {string|Object<string,string>} style The style to set. Either a\n   *     string of css or an object containing property-value pairs.\n   */\n  var applyStyle = function(el, name, style) {\n    if (typeof style === 'string') {\n      el.style.cssText = style;\n    } else {\n      el.style.cssText = '';\n\n      for (var prop in style) {\n        el.style[prop] = style[prop];\n      }\n    }\n  };\n\n\n  /**\n   * Updates a single attribute on an Element.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} value The attribute's value. If the value is an object or\n   *     function it is set on the Element, otherwise, it is set as an HTML\n   *     attribute.\n   */\n  var applyAttributeTyped = function(el, name, value) {\n    var type = typeof value;\n\n    if (type === 'object' || type === 'function') {\n      applyProp(el, name, value);\n    } else {\n      applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\n    }\n  };\n\n\n  /**\n   * Calls the appropriate attribute mutator for this attribute.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} value The attribute's value.\n   */\n  var updateAttribute = function(el, name, value) {\n    var data = getData(el);\n    var attrs = data.attrs;\n\n    if (attrs[name] === value) {\n      return;\n    }\n\n    var mutator = _mutators[name] || _mutators.__all;\n    mutator(el, name, value);\n\n    attrs[name] = value;\n  };\n\n\n  /**\n   * Exposes our default attribute mutators publicly, so they may be used in\n   * custom mutators.\n   * @const {!Object<string, function(!Element, string, *)>}\n   */\n  var _defaults = {\n    applyAttr: applyAttr,\n    applyProp: applyProp,\n    applyStyle: applyStyle\n  };\n\n\n  /**\n   * A publicly mutable object to provide custom mutators for attributes.\n   * @const {!Object<string, function(!Element, string, *)>}\n   */\n  var _mutators = {\n    // Special generic mutator that's called for any attribute that does not\n    // have a specific mutator.\n    __all: applyAttributeTyped,\n\n    // Special case the style attribute\n    'style': applyStyle\n  };\n\n  var SVG_NS = 'http://www.w3.org/2000/svg';\n\n  /**\n   * Enters a tag, checking to see if it is a namespace boundary, and if so,\n   * updates the current namespace.\n   * @param {string} tag The tag to enter.\n   */\n  var enterTag = function(tag) {\n    if (tag === 'svg') {\n      getWalker().enterNamespace(SVG_NS);\n    } else if (tag === 'foreignObject') {\n      getWalker().enterNamespace(undefined);\n    }\n  };\n\n\n  /**\n   * Exits a tag, checking to see if it is a namespace boundary, and if so,\n   * updates the current namespace.\n   * @param {string} tag The tag to enter.\n   */\n  var exitTag = function(tag) {\n    if (tag === 'svg' || tag === 'foreignObject') {\n      getWalker().exitNamespace();\n    }\n  };\n\n\n  /**\n   * Gets the namespace to create an element (of a given tag) in.\n   * @param {string} tag The tag to get the namespace for.\n   * @return {(string|undefined)} The namespace to create the tag in.\n   */\n  var getNamespaceForTag = function(tag) {\n    if (tag === 'svg') {\n      return SVG_NS;\n    }\n\n    return getWalker().getCurrentNamespace();\n  };\n\n  /**\n   * Creates an Element.\n   * @param {!Document} doc The document with which to create the Element.\n   * @param {string} tag The tag for the Element.\n   * @param {?string=} key A key to identify the Element.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of\n   *     the static attributes for the Element.\n   * @return {!Element}\n   */\n  var createElement = function(doc, tag, key, statics) {\n    var namespace = getNamespaceForTag(tag);\n    var el;\n\n    if (namespace) {\n      el = doc.createElementNS(namespace, tag);\n    } else {\n      el = doc.createElement(tag);\n    }\n\n    initData(el, tag, key);\n\n    if (statics) {\n      for (var i = 0; i < statics.length; i += 2) {\n        updateAttribute(el, /** @type {!string}*/(statics[i]), statics[i + 1]);\n      }\n    }\n\n    return el;\n  };\n\n\n  /**\n   * Creates a Node, either a Text or an Element depending on the node name\n   * provided.\n   * @param {!Document} doc The document with which to create the Node.\n   * @param {string} nodeName The tag if creating an element or #text to create\n   *     a Text.\n   * @param {?string=} key A key to identify the Element.\n   * @param {?Array<*>=} statics The static data to initialize the Node\n   *     with. For an Element, an array of attribute name/value pairs of\n   *     the static attributes for the Element.\n   * @return {!Node}\n   */\n  var createNode = function(doc, nodeName, key, statics) {\n    if (nodeName === '#text') {\n      return doc.createTextNode('');\n    }\n\n    return createElement(doc, nodeName, key, statics);\n  };\n\n\n  /**\n   * Creates a mapping that can be used to look up children using a key.\n   * @param {!Node} el\n   * @return {!Object<string, !Element>} A mapping of keys to the children of the\n   *     Element.\n   */\n  var createKeyMap = function(el) {\n    var map = {};\n    var children = el.children;\n    var count = children.length;\n\n    for (var i = 0; i < count; i += 1) {\n      var child = children[i];\n      var key = getData(child).key;\n\n      if (key) {\n        map[key] = child;\n      }\n    }\n\n    return map;\n  };\n\n\n  /**\n   * Retrieves the mapping of key to child node for a given Element, creating it\n   * if necessary.\n   * @param {!Node} el\n   * @return {!Object<string, !Node>} A mapping of keys to child Elements\n   */\n  var getKeyMap = function(el) {\n    var data = getData(el);\n\n    if (!data.keyMap) {\n      data.keyMap = createKeyMap(el);\n    }\n\n    return data.keyMap;\n  };\n\n\n  /**\n   * Retrieves a child from the parent with the given key.\n   * @param {!Node} parent\n   * @param {?string=} key\n   * @return {?Element} The child corresponding to the key.\n   */\n  var getChild = function(parent, key) {\n    return /** @type {?Element} */(key && getKeyMap(parent)[key]);\n  };\n\n\n  /**\n   * Registers an element as being a child. The parent will keep track of the\n   * child using the key. The child can be retrieved using the same key using\n   * getKeyMap. The provided key should be unique within the parent Element.\n   * @param {!Node} parent The parent of child.\n   * @param {string} key A key to identify the child with.\n   * @param {!Node} child The child to register.\n   */\n  var registerChild = function(parent, key, child) {\n    getKeyMap(parent)[key] = child;\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    /**\n    * Makes sure that keyed Element matches the tag name provided.\n    * @param {!Element} node The node that is being matched.\n    * @param {string=} tag The tag name of the Element.\n    * @param {?string=} key The key of the Element.\n    */\n    var assertKeyedTagMatches = function(node, tag, key) {\n      var nodeName = getData(node).nodeName;\n      if (nodeName !== tag) {\n        throw new Error('Was expecting node with key \"' + key + '\" to be a ' +\n            tag + ', not a ' + nodeName + '.');\n      }\n    };\n  }\n\n\n  /**\n   * Checks whether or not a given node matches the specified nodeName and key.\n   *\n   * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n   * @param {?string} nodeName The nodeName for this node.\n   * @param {?string=} key An optional key that identifies a node.\n   * @return {boolean} True if the node matches, false otherwise.\n   */\n  var matches = function(node, nodeName, key) {\n    var data = getData(node);\n\n    // Key check is done using double equals as we want to treat a null key the\n    // same as undefined. This should be okay as the only values allowed are\n    // strings, null and undefined so the == semantics are not too weird.\n    return key == data.key && nodeName === data.nodeName;\n  };\n\n\n  /**\n   * Aligns the virtual Element definition with the actual DOM, moving the\n   * corresponding DOM node to the correct location or creating it if necessary.\n   * @param {string} nodeName For an Element, this should be a valid tag string.\n   *     For a Text, this should be #text.\n   * @param {?string=} key The key used to identify this element.\n   * @param {?Array<*>=} statics For an Element, this should be an array of\n   *     name-value pairs.\n   * @return {!Node} The matching node.\n   */\n  var alignWithDOM = function(nodeName, key, statics) {\n    var walker = getWalker();\n    var currentNode = walker.currentNode;\n    var parent = walker.getCurrentParent();\n    var matchingNode;\n\n    // Check to see if we have a node to reuse\n    if (currentNode && matches(currentNode, nodeName, key)) {\n      matchingNode = currentNode;\n    } else {\n      var existingNode = /** @type {Element} */(getChild(parent, key));\n\n      // Check to see if the node has moved within the parent or if a new one\n      // should be created\n      if (existingNode) {\n        if (process.env.NODE_ENV !== 'production') {\n          assertKeyedTagMatches(existingNode, nodeName, key);\n        }\n\n        matchingNode = existingNode;\n      } else {\n        matchingNode = createNode(walker.doc, nodeName, key, statics);\n\n        if (key) {\n          registerChild(parent, key, matchingNode);\n        }\n      }\n\n      // If the node has a key, remove it from the DOM to prevent a large number\n      // of re-orders in the case that it moved far or was completely removed.\n      // Since we hold on to a reference through the keyMap, we can always add it\n      // back.\n      if (currentNode && getData(currentNode).key) {\n        parent.replaceChild(matchingNode, currentNode);\n        getData(parent).keyMapValid = false;\n      } else {\n        parent.insertBefore(matchingNode, currentNode);\n      }\n\n      walker.currentNode = matchingNode;\n    }\n\n    return matchingNode;\n  };\n\n\n  /**\n   * Clears out any unvisited Nodes, as the corresponding virtual element\n   * functions were never called for them.\n   * @param {!Node} node\n   */\n  var clearUnvisitedDOM = function(node) {\n    var data = getData(node);\n    var keyMap = data.keyMap;\n    var keyMapValid = data.keyMapValid;\n    var lastChild = node.lastChild;\n    var lastVisitedChild = data.lastVisitedChild;\n\n    data.lastVisitedChild = null;\n\n    if (lastChild === lastVisitedChild && keyMapValid) {\n      return;\n    }\n\n    while (lastChild !== lastVisitedChild) {\n      node.removeChild(lastChild);\n      lastChild = node.lastChild;\n    }\n\n    // Clean the keyMap, removing any unusued keys.\n    for (var key in keyMap) {\n      if (!keyMap[key].parentNode) {\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  };\n\n  /**\n   * Enters an Element, setting the current namespace for nested elements.\n   * @param {!Node} node\n   */\n  var enterNode = function(node) {\n    var data = getData(node);\n    enterTag(data.nodeName);\n  };\n\n\n  /**\n   * Exits an Element, unwinding the current namespace to the previous value.\n   * @param {!Node} node\n   */\n  var exitNode = function(node) {\n    var data = getData(node);\n    exitTag(data.nodeName);\n  };\n\n\n  /**\n   * Marks node's parent as having visited node.\n   * @param {!Node} node\n   */\n  var markVisited = function(node) {\n    var walker = getWalker();\n    var parent = walker.getCurrentParent();\n    var data = getData(parent);\n    data.lastVisitedChild = node;\n  };\n\n\n  /**\n   * Changes to the first child of the current node.\n   */\n  var firstChild = function() {\n    var walker = getWalker();\n    enterNode(/** @type {!Node}*/(walker.currentNode));\n    walker.firstChild();\n  };\n\n\n  /**\n   * Changes to the next sibling of the current node.\n   */\n  var nextSibling = function() {\n    var walker = getWalker();\n    markVisited(/** @type {!Node}*/(walker.currentNode));\n    walker.nextSibling();\n  };\n\n\n  /**\n   * Changes to the parent of the current node, removing any unvisited children.\n   */\n  var parentNode = function() {\n    var walker = getWalker();\n    walker.parentNode();\n    exitNode(/** @type {!Node}*/(walker.currentNode));\n  };\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /**\n   * Similar to the built-in Treewalker class, but simplified and allows direct\n   * access to modify the currentNode property.\n   * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n   *     walker should start traversing.\n   * @constructor\n   */\n  function TreeWalker(node) {\n    /**\n     * Keeps track of the current parent node. This is necessary as the traversal\n     * methods may traverse past the last child and we still need a way to get\n     * back to the parent.\n     * @const @private {!Array<!Node>}\n     */\n    this.stack_ = [];\n\n    /**\n     * @type {?Node}\n     */\n    this.currentNode = node;\n\n    /**\n     * @const {!Document}\n     */\n    this.doc = node.ownerDocument;\n\n    /**\n     * Keeps track of what namespace to create new Elements in.\n     * @private\n     * @const {!Array<(string|undefined)>}\n     */\n    this.nsStack_ = [undefined];\n  }\n\n\n  /**\n   * @return {!Node} The current parent of the current location in the subtree.\n   */\n  TreeWalker.prototype.getCurrentParent = function() {\n    return this.stack_[this.stack_.length - 1];\n  };\n\n\n  /**\n   * @return {(string|undefined)} The current namespace to create Elements in.\n   */\n  TreeWalker.prototype.getCurrentNamespace = function() {\n    return this.nsStack_[this.nsStack_.length - 1];\n  };\n\n\n  /**\n   * @param {string=} namespace The namespace to enter.\n   */\n  TreeWalker.prototype.enterNamespace = function(namespace) {\n    this.nsStack_.push(namespace);\n  };\n\n\n  /**\n   * Exits the current namespace\n   */\n  TreeWalker.prototype.exitNamespace = function() {\n    this.nsStack_.pop();\n  };\n\n\n  /**\n   * Changes the current location the firstChild of the current location.\n   */\n  TreeWalker.prototype.firstChild = function() {\n    this.stack_.push(this.currentNode);\n    this.currentNode = this.currentNode.firstChild;\n  };\n\n\n  /**\n   * Changes the current location the nextSibling of the current location.\n   */\n  TreeWalker.prototype.nextSibling = function() {\n    this.currentNode = this.currentNode.nextSibling;\n  };\n\n\n  /**\n   * Changes the current location the parentNode of the current location.\n   */\n  TreeWalker.prototype.parentNode = function() {\n    this.currentNode = this.stack_.pop();\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    var assertNoUnclosedTags = function(root) {\n      var openElement = getWalker().getCurrentParent();\n      if (!openElement) {\n        return;\n      }\n\n      var openTags = [];\n      while (openElement && openElement !== root) {\n        openTags.push(openElement.nodeName.toLowerCase());\n        openElement = openElement.parentNode;\n      }\n\n      throw new Error('One or more tags were not closed:\\n' +\n          openTags.join('\\n'));\n    };\n  }\n\n\n  /**\n   * Patches the document starting at el with the provided function. This function\n   * may be called during an existing patch operation.\n   * @param {!Element|!DocumentFragment} node The Element or Document\n   *     to patch.\n   * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n   *     calls that describe the DOM.\n   * @param {T=} data An argument passed to fn to represent DOM state.\n   * @template T\n   */\n  exports.patch = function(node, fn, data) {\n    var prevWalker = getWalker();\n    setWalker(new TreeWalker(node));\n\n    firstChild();\n    fn(data);\n    parentNode();\n    clearUnvisitedDOM(node);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertNoUnclosedTags(node);\n    }\n\n    setWalker(prevWalker);\n  };\n\n  /**\n   * The offset in the virtual element declaration where the attributes are\n   * specified.\n   * @const\n   */\n  var ATTRIBUTES_OFFSET = 3;\n\n\n  /**\n   * Builds an array of arguments for use with elementOpenStart, attr and\n   * elementOpenEnd.\n   * @const {Array<*>}\n   */\n  var argsBuilder = [];\n\n\n  if (process.env.NODE_ENV !== 'production') {\n    /**\n     * Keeps track whether or not we are in an attributes declaration (after\n     * elementOpenStart, but before elementOpenEnd).\n     * @type {boolean}\n     */\n    var inAttributes = false;\n\n\n    /** Makes sure that the caller is not where attributes are expected. */\n    var assertNotInAttributes = function() {\n      if (inAttributes) {\n        throw new Error('Was not expecting a call to attr or elementOpenEnd, ' +\n            'they must follow a call to elementOpenStart.');\n      }\n    };\n\n\n    /** Makes sure that the caller is where attributes are expected. */\n    var assertInAttributes = function() {\n      if (!inAttributes) {\n        throw new Error('Was expecting a call to attr or elementOpenEnd. ' +\n            'elementOpenStart must be followed by zero or more calls to attr, ' +\n            'then one call to elementOpenEnd.');\n      }\n    };\n\n\n    /**\n     * Makes sure that tags are correctly nested.\n     * @param {string} tag\n     */\n    var assertCloseMatchesOpenTag = function(tag) {\n      var closingNode = getWalker().getCurrentParent();\n      var data = getData(closingNode);\n\n      if (tag !== data.nodeName) {\n        throw new Error('Received a call to close ' + tag + ' but ' +\n              data.nodeName + ' was open.');\n      }\n    };\n\n\n    /** Updates the state to being in an attribute declaration. */\n    var setInAttributes = function() {\n      inAttributes = true;\n    };\n\n\n    /** Updates the state to not being in an attribute declaration. */\n    var setNotInAttributes = function() {\n      inAttributes = false;\n    };\n  }\n\n\n  /**\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   * @param {...(string|number|boolean)} var_args\n   *     Functions to format the value which are called only when the value has\n   *     changed.\n   * @return {!Element} The corresponding Element.\n   */\n  exports.elementOpen = function(tag, key, statics, var_args) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes();\n    }\n\n    var node = /** @type {!Element}*/(alignWithDOM(tag, key, statics));\n    var data = getData(node);\n\n    /*\n     * Checks to see if one or more attributes have changed for a given Element.\n     * When no attributes have changed, this is much faster than checking each\n     * individual argument. When attributes have changed, the overhead of this is\n     * minimal.\n     */\n    var attrsArr = data.attrsArr;\n    var attrsChanged = false;\n    var i = ATTRIBUTES_OFFSET;\n    var j = 0;\n\n    for (; i < arguments.length; i += 1, j += 1) {\n      if (attrsArr[j] !== arguments[i]) {\n        attrsChanged = true;\n        break;\n      }\n    }\n\n    for (; i < arguments.length; i += 1, j += 1) {\n      attrsArr[j] = arguments[i];\n    }\n\n    if (j < attrsArr.length) {\n      attrsChanged = true;\n      attrsArr.length = j;\n    }\n\n    /*\n     * Actually perform the attribute update.\n     */\n    if (attrsChanged) {\n      var attr, newAttrs = data.newAttrs;\n\n      for (attr in newAttrs) {\n        newAttrs[attr] = undefined;\n      }\n\n      for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n        newAttrs[arguments[i]] = arguments[i + 1];\n      }\n\n      for (attr in newAttrs) {\n        updateAttribute(node, attr, newAttrs[attr]);\n      }\n    }\n\n    firstChild();\n    return node;\n  };\n\n\n  /**\n   * Declares a virtual Element at the current location in the document. This\n   * corresponds to an opening tag and a elementClose tag is required. This is\n   * like elementOpen, but the attributes are defined using the attr function\n   * rather than being passed as arguments. Must be folllowed by 0 or more calls\n   * to attr, then a call to elementOpenEnd.\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   */\n  exports.elementOpenStart = function(tag, key, statics) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes();\n      setInAttributes();\n    }\n\n    argsBuilder[0] = tag;\n    argsBuilder[1] = key;\n    argsBuilder[2] = statics;\n  };\n\n\n  /***\n   * Defines a virtual attribute at this point of the DOM. This is only valid\n   * when called between elementOpenStart and elementOpenEnd.\n   *\n   * @param {string} name\n   * @param {*} value\n   */\n  exports.attr = function(name, value) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertInAttributes();\n    }\n\n    argsBuilder.push(name, value);\n  };\n\n\n  /**\n   * Closes an open tag started with elementOpenStart.\n   * @return {!Element} The corresponding Element.\n   */\n  exports.elementOpenEnd = function() {\n    if (process.env.NODE_ENV !== 'production') {\n      assertInAttributes();\n      setNotInAttributes();\n    }\n\n    var node = exports.elementOpen.apply(null, argsBuilder);\n    argsBuilder.length = 0;\n    return node;\n  };\n\n\n  /**\n   * Closes an open virtual Element.\n   *\n   * @param {string} tag The element's tag.\n   * @return {!Element} The corresponding Element.\n   */\n  exports.elementClose = function(tag) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes();\n      assertCloseMatchesOpenTag(tag);\n    }\n\n    parentNode();\n\n    var node = /** @type {!Element} */(getWalker().currentNode);\n    clearUnvisitedDOM(node);\n\n    nextSibling();\n    return node;\n  };\n\n\n  /**\n   * Declares a virtual Element at the current location in the document that has\n   * no children.\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n   *     for the Element.\n   * @return {!Element} The corresponding Element.\n   */\n  exports.elementVoid = function(tag, key, statics, var_args) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes();\n    }\n\n    var node = exports.elementOpen.apply(null, arguments);\n    exports.elementClose.apply(null, arguments);\n    return node;\n  };\n\n\n  /**\n   * Declares a virtual Text at this point in the document.\n   *\n   * @param {string|number|boolean} value The value of the Text.\n   * @param {...(function(string|number|boolean):string)} var_args\n   *     Functions to format the value which are called only when the value has\n   *     changed.\n   * @return {!Text} The corresponding text node.\n   */\n  exports.text = function(value, var_args) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes();\n    }\n\n    var node = /** @type {!Text}*/(alignWithDOM('#text', null));\n    var data = getData(node);\n\n    if (data.text !== value) {\n      data.text = /** @type {string} */(value);\n\n      var formatted = value;\n      for (var i = 1; i < arguments.length; i += 1) {\n        formatted = arguments[i](formatted);\n      }\n\n      node.data = formatted;\n    }\n\n    nextSibling();\n    return node;\n  };\n\n  /**\n   * Publicly exports the mutator hooks from various internal modules.\n   * Note that mutating these objects will alter the behavior of the internal\n   * code.\n   * {Object<string, Object<string, function>>}\n   */\n  exports.mutators = {\n    attributes: _mutators\n  };\n\n  /**\n   * Publicly exports the default mutators from various internal modules.\n   * Note that mutating these objects will have no affect on the internal code,\n   * these are exposed only to be used by custom mutators.\n   * {Object<string, Object<string, function>>}\n   */\n  exports.defaults = {\n    attributes: _defaults\n  };\n\n}));"],"sourceRoot":"/source/"}