{"version":3,"file":"incremental-dom-min.js","sources":["src/util.ts","src/attributes.ts","src/assertions.ts","src/dom_util.ts","src/node_data.ts","src/nodes.ts","src/core.ts","src/virtual_elements.ts","src/symbols.ts","src/global.ts","src/notifications.ts","src/context.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n/**\n * A constructor function that will create blank objects.\n */\nfunction Blank() {}\n\nBlank.prototype = Object.create(null);\n\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param map The map to check.\n * @param property The property to check.\n * @return Whether map has property.\n */\nfunction has(map: object, property: string): boolean {\n  return hasOwnProperty.call(map, property);\n}\n\n\n/**\n * Creates an map object without a prototype.\n */\n// tslint:disable-next-line:no-any\nfunction createMap(): any {\n  // tslint:disable-next-line:no-any\n  return new (Blank as any)();\n}\n\n\n/**\n * Truncates an array, removing items up until length.\n * @param arr The array to truncate.\n * @param length The new length of the array.\n */\nfunction truncateArray(arr: Array<{}|null|undefined>, length: number) {\n  while (arr.length > length) {\n    arr.pop();\n  }\n}\n\nexport {createMap, has, truncateArray,};\n","/**\n * @fileoverview\n * @suppress {extraRequire}\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {AttrMutatorConfig} from './types';\nimport {symbols} from './symbols';\nimport {createMap, has} from './util';\n\n\n/**\n * Returns the namespace to use for the attribute.\n */\nfunction getNamespace(name: string): string|undefined {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n\n  return undefined;\n}\n\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n */\n// tslint:disable-next-line:no-any\nfunction applyAttr(el: Element, name: string, value: any) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    const attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, String(value));\n    } else {\n      el.setAttribute(name, String(value));\n    }\n  }\n}\n\n/**\n * Applies a property to a given Element.\n */\n// tslint:disable-next-line:no-any\nfunction applyProp(el: Element, name: string, value: any) {\n  // tslint:disable-next-line:no-any\n  (el as any)[name] = value;\n}\n\n\n/**\n * Applies a value to a style declaration. Supports CSS custom properties by\n * setting properties containing a dash using CSSStyleDeclaration.setProperty.\n */\nfunction setStyleValue(\n    style: CSSStyleDeclaration, prop: string, value: string) {\n  if (prop.indexOf('-') >= 0) {\n    style.setProperty(prop, value);\n  } else {\n    // TODO(tomnguyen) Figure out why this is necessary.\n    // tslint:disable-next-line:no-any\n    (style as any)[prop] = value;\n  }\n}\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param el\n * @param name The attribute's name.\n * @param  style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nfunction applyStyle(\n    el: HTMLElement, name: string, style: string|{[k: string]: string}) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    const elStyle = el.style;\n\n    for (const prop in style) {\n      if (has(style, prop)) {\n        setStyleValue(elStyle, prop, style[prop]);\n      }\n    }\n  }\n}\n\n\n/**\n * Updates a single attribute on an Element.\n * @param el\n * @param name The attribute's name.\n * @param value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nfunction applyAttributeTyped(el: HTMLElement, name: string, value: {}) {\n  const type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, value);\n  }\n}\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * NB: The result of createMap() has to be recast since closure compiler\n * will just assume attributes is \"any\" otherwise and throws away\n * the type annotation set by tsickle.\n */\nconst attributes: AttrMutatorConfig = (createMap() as AttrMutatorConfig);\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes['style'] = applyStyle;\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n */\nfunction updateAttribute(\n    el: HTMLElement, name: string, value: {}|null|undefined) {\n  const mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n}\n\n\n\nexport {\n  updateAttribute,\n  applyProp,\n  applyAttr,\n  attributes,\n};\n","/**\n * @fileoverview\n * @suppress {extraRequire}\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {DEBUG} from './global';\nimport {NameOrCtorDef} from './types';\n\n\n/**\n * Keeps track whether or not we are in an attributes declaration (after\n * elementOpenStart, but before elementOpenEnd).\n */\nlet inAttributes = false;\n\n\n/**\n * Keeps track whether or not we are in an element that should not have its\n * children cleared.\n */\nlet inSkip = false;\n\n\n/**\n * Makes sure that there is a current patch context.\n */\nfunction assertInPatch(functionName: string, context: Document) {\n  if (!context) {\n    throw new Error('Cannot call ' + functionName + '() unless in patch.');\n  }\n}\n\n\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param openElement\n * @param root\n */\nfunction assertNoUnclosedTags(\n    openElement: Node|null, root: Node|DocumentFragment) {\n  if (openElement === root) {\n    return;\n  }\n\n  let currentElement = openElement;\n  const openTags: string[] = [];\n  while (currentElement && currentElement !== root) {\n    openTags.push(currentElement.nodeName.toLowerCase());\n    currentElement = currentElement.parentNode;\n  }\n\n  throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n}\n\n\n/**\n * Makes sure that node being outer patched has a parent node.\n */\nfunction assertPatchOuterHasParentNode(parent: Node|null) {\n  if (!parent) {\n    console.warn(\n      'patchOuter requires the node have a parent if there is a key.');\n  }\n}\n\n\n/**\n * Makes sure that the caller is not where attributes are expected.\n */\nfunction assertNotInAttributes(functionName: string) {\n  if (inAttributes) {\n    throw new Error(\n        functionName + '() can not be called between ' +\n        'elementOpenStart() and elementOpenEnd().');\n  }\n}\n\n\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n */\nfunction assertNotInSkip(functionName: string) {\n  if (inSkip) {\n    throw new Error(\n        functionName + '() may not be called inside an element ' +\n        'that has called skip().');\n  }\n}\n\n\n/**\n * Makes sure that the caller is where attributes are expected.\n */\nfunction assertInAttributes(functionName: string) {\n  if (!inAttributes) {\n    throw new Error(\n        functionName + '() can only be called after calling ' +\n        'elementOpenStart().');\n  }\n}\n\n\n/**\n * Makes sure the patch closes virtual attributes call\n */\nfunction assertVirtualAttributesClosed() {\n  if (inAttributes) {\n    throw new Error(\n        'elementOpenEnd() must be called after calling ' +\n        'elementOpenStart().');\n  }\n}\n\n\n/**\n * Makes sure that tags are correctly nested.\n */\nfunction assertCloseMatchesOpenTag(\n    currentNameOrCtor: NameOrCtorDef, nameOrCtor: NameOrCtorDef) {\n  if (currentNameOrCtor !== nameOrCtor) {\n    throw new Error(\n        'Received a call to close \"' + nameOrCtor + '\" but \"' +\n        currentNameOrCtor + '\" was open.');\n  }\n}\n\n\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n */\nfunction assertNoChildrenDeclaredYet(\n    functionName: string, previousNode: Node|null) {\n  if (previousNode !== null) {\n    throw new Error(\n        functionName + '() must come before any child ' +\n        'declarations inside the current element.');\n  }\n}\n\n\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param maybeStartNode The value for the currentNode when the patch\n *     started.\n * @param currentNode The currentNode when the patch finished.\n * @param expectedNextNode The Node that is expected to follow the\n *    currentNode after the patch;\n * @param  expectedPrevNode The Node that is expected to preceed the\n *    currentNode after the patch.\n */\nfunction assertPatchElementNoExtras(\n    maybeStartNode: Node|null, maybeCurrentNode: Node|null,\n    expectedNextNode: Node|null, expectedPrevNode: Node|null) {\n  assert(maybeStartNode);\n  const startNode = maybeStartNode!;\n  // tslint:disable-next-line:no-unnecessary-type-assertion\n  const currentNode = maybeCurrentNode!;\n  const wasUpdated = currentNode.nextSibling === expectedNextNode &&\n      currentNode.previousSibling === expectedPrevNode;\n  const wasChanged = currentNode.nextSibling === startNode.nextSibling &&\n      currentNode.previousSibling === expectedPrevNode;\n  const wasRemoved = currentNode === startNode;\n\n  if (!wasUpdated && !wasChanged && !wasRemoved) {\n    throw new Error(\n        'There must be exactly one top level call corresponding ' +\n        'to the patched element.');\n  }\n}\n\n\n/**\n * Updates the state of being in an attribute declaration.\n * @return the previous value.\n */\nfunction setInAttributes(value: boolean) {\n  const previous = inAttributes;\n  inAttributes = value;\n  return previous;\n}\n\n\n/**\n * Updates the state of being in a skip element.\n * @return the previous value.\n */\nfunction setInSkip(value: boolean) {\n  const previous = inSkip;\n  inSkip = value;\n  return previous;\n}\n\n/**\n * Asserts that a value exists and is not null or undefined. goog.asserts\n * is not used in order to avoid dependencies on external code.\n */\nfunction assert<T extends {}>(val: T|null|undefined): T {\n  if (DEBUG && !val) {\n    throw new Error('Expected value to be defined');\n  }\n  return val!;\n}\n\n\nexport {\n  assert,\n  assertInPatch,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertInAttributes,\n  assertCloseMatchesOpenTag,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertNotInSkip,\n  assertPatchElementNoExtras,\n  assertPatchOuterHasParentNode,\n  setInAttributes,\n  setInSkip,\n};\n","/**\n * @fileoverview\n * @suppress {extraRequire}\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {assert} from './assertions';\n\n/**\n * Checks if the node is the root of a document. This is either a Document\n * or ShadowRoot. DocumentFragments are included for simplicity of the\n * implementation, though we only want to consider Documents or ShadowRoots.\n * @param node The node to check.\n * @return True if the node the root of a document, false otherwise.\n */\nfunction isDocumentRoot(node: Node): node is Document|ShadowRoot {\n  return node.nodeType === 11 || node.nodeType === 9;\n}\n\n/**\n * Checks if the node is an Element. This is faster than an instanceof check.\n * @param node The node to check.\n * @return Whether or not the node is an Element.\n */\nfunction isElement(node: Node): node is Element {\n  return node.nodeType === 1;\n}\n\n/**\n * @param  node The node to start at, inclusive.\n * @param  root The root ancestor to get until, exclusive.\n * @return The ancestry of DOM nodes.\n */\nfunction getAncestry(node: Node, root: Node|null) {\n  const ancestry: Node[] = [];\n  let cur: Node|null = node;\n\n  while (cur !== root) {\n    const n: Node = cur!;\n    ancestry.push(n);\n    cur = n.parentNode;\n  }\n\n  return ancestry;\n}\n\n/**\n * return The root node of the DOM tree that contains this node.\n */\nconst getRootNode =\n    // tslint:disable-next-line:no-any b/79476176\n    (Node as any).prototype.getRootNode || function(this: Node) {\n      // tslint:disable-next-line:no-unnecessary-type-assertion b/77361044\n      let cur: Node|null = this as Node;\n      let prev = cur;\n\n      while (cur) {\n        prev = cur;\n        cur = cur.parentNode;\n      }\n\n      return prev;\n    };\n\n\n/**\n * @param node The node to get the activeElement for.\n * @return The activeElement in the Document or ShadowRoot\n *     corresponding to node, if present.\n */\nfunction getActiveElement(node: Node): Element|null {\n  const root = getRootNode.call(node);\n  return isDocumentRoot(root) ? root.activeElement : null;\n}\n\n\n/**\n * Gets the path of nodes that contain the focused node in the same document as\n * a reference node, up until the root.\n * @param node The reference node to get the activeElement for.\n * @param root The root to get the focused path until.\n */\nfunction getFocusedPath(node: Node, root: Node|null): Node[] {\n  const activeElement = getActiveElement(node);\n\n  if (!activeElement || !node.contains(activeElement)) {\n    return [];\n  }\n\n  return getAncestry(activeElement, root);\n}\n\n\n/**\n * Like insertBefore, but instead instead of moving the desired node, instead\n * moves all the other nodes after.\n * @param parentNode\n * @param node\n * @param referenceNode\n */\nfunction moveBefore(parentNode: Node, node: Node, referenceNode: Node|null) {\n  const insertReferenceNode = node.nextSibling;\n  let cur = referenceNode;\n\n  while (cur !== null && cur !== node) {\n    const next = cur.nextSibling;\n    parentNode.insertBefore(cur, insertReferenceNode);\n    cur = next;\n  }\n}\n\n\nexport {\n  isElement,\n  getFocusedPath,\n  moveBefore,\n};\n","/**\n * @fileoverview\n * @suppress {extraRequire}\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Key, NameOrCtorDef} from './types';\nimport {isElement} from './dom_util';\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n */\nexport class NodeData {\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   */\n  // tslint:disable-next-line:no-any\n  readonly attrsArr: any[] = [];\n\n  /**\n   * Whether or not the statics have been applied for the node yet.\n   */\n  staticsApplied = false;\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   */\n  key: Key;\n\n  text: string|null = null;\n\n  /**\n   * The nodeName or contructor for the Node.\n   */\n  readonly nameOrCtor: NameOrCtorDef;\n\n  /**\n   * Whether or the associated node is, or contains, a focused Element.\n   */\n  focused = false;\n\n  constructor(nameOrCtor: NameOrCtorDef, key: Key) {\n    this.nameOrCtor = nameOrCtor;\n    this.key = key;\n  }\n}\n\ndeclare global {\n  interface Node {\n    '__incrementalDOMData': NodeData|null;\n  }\n}\n\n/**\n * Initializes a NodeData object for a Node.\n */\nfunction initData(\n    node: Node, nameOrCtor: NameOrCtorDef, key: Key): NodeData {\n  const data = new NodeData(nameOrCtor, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n}\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n */\nfunction getData(node: Node) {\n  importNode(node);\n  return node['__incrementalDOMData']!;\n}\n\n\n/**\n * Imports node and its subtree, initializing caches.\n */\nfunction importNode(node: Node) {\n  if (node['__incrementalDOMData']) {\n    return;\n  }\n\n  const nodeName = isElement(node) ? node.localName : node.nodeName;\n  const key = isElement(node) ? node.getAttribute('key') : null;\n  const data = initData(node, nodeName!, key);\n\n  if (isElement(node)) {\n    const attributes = node.attributes;\n    const attrsArr = data.attrsArr;\n\n    for (let i = 0; i < attributes.length; i += 1) {\n      const attr = attributes[i];\n      const name = attr.name;\n      const value = attr.value;\n\n      attrsArr.push(name);\n      attrsArr.push(value);\n    }\n  }\n\n  for (let child = node.firstChild; child; child = child.nextSibling) {\n    importNode(child);\n  }\n}\n\n/**\n * Clears all caches from a node and all of its children.\n */\nfunction clearCache(node: Node) {\n  node['__incrementalDOMData'] = null;\n\n  for (let child = node.firstChild; child; child = child.nextSibling) {\n    clearCache(child);\n  }\n}\n\n\n/** */\nexport {\n  getData,\n  initData,\n  importNode,\n  clearCache,\n};\n","/**\n * @fileoverview\n * @suppress {extraRequire}\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getData, initData} from './node_data';\nimport {Key, NameOrCtorDef} from './types';\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n */\nfunction getNamespaceForTag(tag: string, parent: Node|null) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (parent == null) {\n    return null;\n  }\n\n  if (getData(parent).nameOrCtor === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n}\n\n\n/**\n * Creates an Element.\n * @param doc The document with which to create the Element.\n * @param nameOrCtor The tag or constructor for the Element.\n * @param key A key to identify the Element.\n * @param  typeId The type identifier for the Element.\n */\nfunction createElement(\n    doc: Document, parent: Node|null, nameOrCtor: NameOrCtorDef, key: Key)\n    : Element {\n  let el;\n\n  if (nameOrCtor instanceof Function) {\n    el = new nameOrCtor();\n  } else {\n    const namespace = getNamespaceForTag(nameOrCtor, parent);\n\n    if (namespace) {\n      el = doc.createElementNS(namespace, nameOrCtor);\n    } else {\n      el = doc.createElement(nameOrCtor);\n    }\n  }\n\n  initData(el, nameOrCtor, key);\n\n  return el;\n}\n\n\n/**\n * Creates a Text Node.\n * @param doc The document with which to create the Element.\n * @return\n */\nfunction createText(doc: Document) {\n  const node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n}\n\n\n/** */\nexport {\n  createElement,\n  createText,\n};\n","/**\n * @fileoverview\n * @suppress {extraRequire}\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {assert, assertInPatch, assertNoChildrenDeclaredYet, assertNotInAttributes, assertNoUnclosedTags, assertPatchElementNoExtras, assertPatchOuterHasParentNode, assertVirtualAttributesClosed, setInAttributes, setInSkip} from './assertions';\nimport {Context} from './context';\nimport {getFocusedPath, moveBefore} from './dom_util';\nimport {DEBUG} from './global';\nimport {getData} from './node_data';\nimport {createElement, createText} from './nodes';\nimport {Key, NameOrCtorDef} from './types';\n\nlet context: Context|null = null;\n\nlet currentNode: Node|null = null;\n\nlet currentParent: Node|null = null;\n\nlet doc: Document|null = null;\n\n/**\n * Used to build up call arguments. Each patch call gets a separate copy, so\n * this works with nested calls to patch.\n */\nlet argsBuilder: Array<{}|null|undefined> = [];\n\n// Certain attributes can be set on nodes. See ../test/functional/attributes\ndeclare global {\n  interface HTMLElement {\n    fn: Function|undefined;\n    obj: object|undefined;\n  }\n}\n\n\n/**\n * TODO(sparhami) We should just export argsBuilder directly when Closure\n * Compiler supports ES6 directly.\n */\nfunction getArgsBuilder(): Array<{}|null|undefined>{\n  return argsBuilder;\n}\n\n/**\n * @param focusPath The nodes to mark.\n * @param focused Whether or not they are focused.\n */\nfunction markFocused(focusPath: Node[], focused: boolean) {\n  for (let i = 0; i < focusPath.length; i += 1) {\n    getData(focusPath[i]).focused = focused;\n  }\n}\n\ntype PatchFunction<T, R> =\n    (el: Element|DocumentFragment, template: (a: T|undefined) => void,\n     data?: T|undefined) => R;\n\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n */\nfunction patchFactory<T, R>(run: PatchFunction<T, R>): PatchFunction<T, R> {\n  const f: PatchFunction<T, R> = (node, fn, data) => {\n    const prevContext = context;\n    const prevDoc = doc;\n    const prevArgsBuilder = argsBuilder;\n    const prevCurrentNode = currentNode;\n    const prevCurrentParent = currentParent;\n    let previousInAttributes = false;\n    let previousInSkip = false;\n\n    context = new Context();\n    doc = node.ownerDocument;\n    argsBuilder = [];\n    currentParent = node.parentNode;\n\n    if (DEBUG) {\n      previousInAttributes = setInAttributes(false);\n      previousInSkip = setInSkip(false);\n    }\n\n    const focusPath = getFocusedPath(node, currentParent);\n\n    try {\n      markFocused(focusPath, true);\n\n      const retVal = run(node, fn, data);\n      if (DEBUG) {\n        assertVirtualAttributesClosed();\n      }\n\n      return retVal;\n    } finally {\n      markFocused(focusPath, false);\n\n      doc = prevDoc;\n      argsBuilder = prevArgsBuilder;\n      currentNode = prevCurrentNode;\n      currentParent = prevCurrentParent;\n      context.notifyChanges();\n\n      // Needs to be done after assertions because assertions rely on state\n      // from these methods.\n      setInAttributes(previousInAttributes);\n      setInSkip(previousInSkip);\n      context = prevContext;\n    }\n  };\n  return f;\n}\n\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n */\nconst patchInner = patchFactory((node, fn, data) => {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if (DEBUG) {\n    assertNoUnclosedTags(currentNode, node);\n  }\n\n  return node;\n});\n\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n */\nconst patchOuter = patchFactory((node, fn, data) => {\n  // tslint:disable-next-line:no-any\n  const startNode = (({nextSibling: node}) as any) as Element;\n  let expectedNextNode: Node|null = null;\n  let expectedPrevNode: Node|null = null;\n\n  if (DEBUG) {\n    expectedNextNode = node.nextSibling;\n    expectedPrevNode = node.previousSibling;\n  }\n\n  currentNode = startNode;\n  fn(data);\n\n  if (DEBUG) {\n    assertPatchOuterHasParentNode(currentParent);\n    assertPatchElementNoExtras(\n        startNode, currentNode, expectedNextNode, expectedPrevNode);\n  }\n\n  if (currentParent) {\n    clearUnvisitedDOM(currentParent, getNextNode(), node.nextSibling);\n  }\n\n  return (startNode === currentNode) ? null : currentNode;\n});\n\n\n/**\n * Checks whether or not the current node matches the specified nameOrCtor and\n * key.\n * @param matchNode A node to match the data to.\n * @param nameOrCtor The name or constructor to check for.\n * @param key The key used to identify the Node.\n * @return True if the node matches, false otherwise.\n */\nfunction matches(\n    matchNode: Node, nameOrCtor: NameOrCtorDef, key: Key) {\n  const data = getData(matchNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  // tslint:disable-next-line:triple-equals\n  return nameOrCtor == data.nameOrCtor && key == data.key;\n}\n\n\n/**\n * Finds the matching node, starting at `node` and looking at the subsequent\n * siblings if a key is used.\n * @param node The node to start looking at.\n * @param nameOrCtor The name or constructor for the Node.\n * @param key The key used to identify the Node.\n */\nfunction getMatchingNode(\n    matchNode: Node|null, nameOrCtor: NameOrCtorDef, key: Key): Node|null {\n  if (!matchNode) {\n    return null;\n  }\n\n  if (matches(matchNode, nameOrCtor, key)) {\n    return matchNode;\n  }\n\n  if (!key) {\n    return null;\n  }\n\n  return getMatchingNode(matchNode.nextSibling, nameOrCtor, key);\n}\n\n\n/**\n * Creates a Node and marking it as created.\n * @param nameOrCtor The name or constructor for the Node.\n * @param key The key used to identify the Node.\n * @return The newly created node.\n */\nfunction createNode(nameOrCtor: NameOrCtorDef, key:Key): Node {\n  let node;\n\n  if (nameOrCtor === '#text') {\n    node = createText(doc!);\n  } else {\n    node = createElement(doc!, currentParent!, nameOrCtor, key);\n  }\n\n  context!.markCreated(node);\n\n  return node;\n}\n\n\n/**\n * Aligns the virtual Node definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param nameOrCtor The name or constructor for the Node.\n * @param key The key used to identify the Node.\n */\nfunction alignWithDOM(nameOrCtor: NameOrCtorDef, key: Key) {\n  const existingNode = getMatchingNode(currentNode, nameOrCtor, key);\n  const node = existingNode || createNode(nameOrCtor, key);\n\n  // If we are at the matching node, then we are done.\n  if (node === currentNode) {\n    return;\n  }\n\n  // Re-order the node into the right position, preserving focus if either\n  // node or currentNode are focused by making sure that they are not detached\n  // from the DOM.\n  if (getData(node).focused) {\n    // Move everything else before the node.\n    moveBefore(currentParent!, node, currentNode);\n  } else {\n    currentParent!.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n}\n\n\n/**\n * Clears out any unvisited Nodes in a given range.\n * @param maybeParentNode\n * @param startNode The node to start clearing from, inclusive.\n * @param endNode The node to clear until, exclusive.\n */\nfunction clearUnvisitedDOM(\n    maybeParentNode: Node|null, startNode: Node|null, endNode: Node|null) {\n  const parentNode = maybeParentNode!;\n  let child = startNode;\n\n  while (child !== endNode) {\n    const next = child!.nextSibling;\n    parentNode.removeChild(child!);\n    context!.markDeleted(child!);\n    child = next;\n  }\n}\n\n\n/**\n * Changes to the first child of the current node.\n */\nfunction enterNode() {\n  currentParent = currentNode;\n  currentNode = null;\n}\n\n\n/**\n * @return The next Node to be patched.\n */\nfunction getNextNode(): Node|null {\n  if (currentNode) {\n    return currentNode.nextSibling;\n  } else {\n    return currentParent!.firstChild;\n  }\n}\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nfunction nextNode() {\n  currentNode = getNextNode();\n}\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nfunction exitNode() {\n  clearUnvisitedDOM(currentParent, getNextNode(), null);\n\n  currentNode = currentParent;\n  currentParent = currentParent!.parentNode;\n}\n\n\n/**\n * Makes sure that the current node is an Element with a matching nameOrCtor and\n * key.\n *\n * @param nameOrCtor The tag or constructor for the Element.\n * @param key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @return The corresponding Element.\n */\nfunction open(nameOrCtor: NameOrCtorDef, key?: Key): HTMLElement {\n  nextNode();\n  alignWithDOM(nameOrCtor, key);\n  enterNode();\n  return (currentParent as HTMLElement);\n}\n\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n */\nfunction close() {\n  if (DEBUG) {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return (currentNode) as Element;\n}\n\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n */\nfunction text(): Text {\n  nextNode();\n  alignWithDOM('#text', null);\n  return (currentNode) as Text;\n}\n\n\n/**\n * Gets the current Element being patched.\n */\nfunction currentElement(): HTMLElement {\n  if (DEBUG) {\n    assertInPatch('currentElement', doc!);\n    assertNotInAttributes('currentElement');\n  }\n  return (currentParent) as HTMLElement;\n}\n\n\n/**\n * @return The Node that will be evaluated for the next instruction.\n */\nfunction currentPointer(): Node {\n  if (DEBUG) {\n    assertInPatch('currentPointer', doc!);\n    assertNotInAttributes('currentPointer');\n  }\n  // TODO(tomnguyen): assert that this is not null\n  return getNextNode()!;\n}\n\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nfunction skip() {\n  if (DEBUG) {\n    assertNoChildrenDeclaredYet('skip', currentNode);\n    setInSkip(true);\n  }\n  currentNode = currentParent!.lastChild;\n}\n\n\n/** */\nexport {\n  getArgsBuilder,\n  text,\n  patchInner,\n  patchOuter,\n  open,\n  close,\n  currentElement,\n  currentPointer,\n  skip,\n  nextNode as skipNode,\n};\n","/**\n * @fileoverview\n * @suppress {extraRequire}\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {assert, assertCloseMatchesOpenTag, assertInAttributes, assertNotInAttributes, assertNotInSkip, setInAttributes} from './assertions';\nimport {updateAttribute} from './attributes';\nimport {getArgsBuilder, close, open, text as coreText} from './core';\nimport {DEBUG} from './global';\nimport {getData} from './node_data';\nimport {Key, NameOrCtorDef, Statics} from './types';\nimport {createMap, truncateArray} from './util';\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n */\nconst ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Used to keep track of the previous values when a 2-way diff is necessary.\n * This object is reused.s\n */\nconst prevAttrsMap = createMap();\n\n\n/**\n * @param  nameOrCtor The Element's tag or constructor.\n * @param  key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param statics An array of attribute name/value pairs of the static\n *     attributes for the Element. Attributes will only be set once when the\n *     Element is created.\n * @param varArgs, Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return The corresponding Element.\n */\nfunction elementOpen(\n    nameOrCtor: NameOrCtorDef, key?: Key,\n    // Ideally we could tag statics and varArgs as an array where every odd\n    // element is a string and every even element is any, but this is hard.\n    // tslint:disable-next-line:no-any\n    statics?: Statics, ...varArgs: any[]) {\n  if (DEBUG) {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  const node = open(nameOrCtor, key);\n  const data = getData(node);\n\n  if (!data.staticsApplied) {\n    if (statics) {\n      for (let i = 0; i < statics.length; i += 2) {\n        const name = (statics[i]) as string;\n        const value = statics[i + 1];\n        updateAttribute(node, name, value);\n      }\n    }\n    // Down the road, we may want to keep track of the statics array to use it\n    // as an additional signal about whether a node matches or not. For now,\n    // just use a marker so that we do not reapply statics.\n    data.staticsApplied = true;\n  }\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  const attrsArr = data.attrsArr;\n  const isNew = !attrsArr.length;\n  let i = ATTRIBUTES_OFFSET;\n  let j = 0;\n\n  for (; i < arguments.length; i += 2, j += 2) {\n    const name = arguments[i];\n    if (isNew) {\n      attrsArr[j] = name;\n    } else if (attrsArr[j] !== name) {\n      break;\n    }\n\n    const value = arguments[i + 1];\n    if (isNew || attrsArr[j + 1] !== value) {\n      attrsArr[j + 1] = value;\n      updateAttribute(node, name, value);\n    }\n  }\n\n  /*\n   * Items did not line up exactly as before, need to make sure old items are\n   * removed. This can happen if using conditional logic when declaring\n   * attrs through the elementOpenStart flow or if one element is reused in\n   * the place of another.\n   */\n  if (i < arguments.length || j < attrsArr.length) {\n    const attrsStart = j;\n\n    for (; j < attrsArr.length; j += 2) {\n      prevAttrsMap[attrsArr[j]] = attrsArr[j + 1];\n    }\n\n    for (j = attrsStart; i < arguments.length; i += 2, j += 2) {\n      const name = arguments[i];\n      const value = arguments[i + 1];\n\n      if (prevAttrsMap[name] !== value) {\n        updateAttribute(node, name, value);\n      }\n\n      attrsArr[j] = name;\n      attrsArr[j + 1] = value;\n\n      delete prevAttrsMap[name];\n    }\n\n    truncateArray(attrsArr, j);\n\n    /*\n     * At this point, only have attributes that were present before, but have\n     * been removed.\n     */\n    for (const name of Object.keys(prevAttrsMap)) {\n      updateAttribute(node, name, undefined);\n      delete prevAttrsMap[name];\n    }\n  }\n\n  return node;\n}\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param nameOrCtor The Element's tag or constructor.\n * @param key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param statics An array of attribute name/value pairs of the static\n *     attributes for the Element. Attributes will only be set once when the\n *     Element is created.\n */\nfunction elementOpenStart(\n  nameOrCtor: NameOrCtorDef, key?: Key, statics?: Statics) {\n  const argsBuilder = getArgsBuilder();\n\n  if (DEBUG) {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = nameOrCtor;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n}\n\n\n/**\n * Allows you to define a key after an elementOpenStart. This is useful in\n * templates that define key after an element has been opened ie\n * `<div key('foo')></div>`.\n */\nfunction key(key:string) {\n  const argsBuilder = getArgsBuilder();\n\n  if (DEBUG) {\n    assertInAttributes('key');\n    assert(argsBuilder);\n  }\n  argsBuilder[1] = key;\n}\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n */\n// tslint:disable-next-line:no-any\nfunction attr(name: string, value: any) {\n  const argsBuilder = getArgsBuilder();\n\n  if (DEBUG) {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name);\n  argsBuilder.push(value);\n}\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return The corresponding Element.\n */\nfunction elementOpenEnd(): HTMLElement {\n  const argsBuilder = getArgsBuilder();\n\n  if (DEBUG) {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  assert(argsBuilder);\n  const node = elementOpen.apply(null, argsBuilder!);\n  truncateArray(argsBuilder, 0);\n  return node;\n}\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param nameOrCtor The Element's tag or constructor.\n * @return The corresponding Element.\n */\nfunction elementClose(nameOrCtor: NameOrCtorDef): Element {\n  if (DEBUG) {\n    assertNotInAttributes('elementClose');\n  }\n\n  const node = close();\n\n  if (DEBUG) {\n    assertCloseMatchesOpenTag(getData(node).nameOrCtor, nameOrCtor);\n  }\n\n  return node;\n}\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param nameOrCtor The Element's tag or constructor.\n * @param key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param statics An array of attribute name/value pairs of the static\n *     attributes for the Element. Attributes will only be set once when the\n *     Element is created.\n * @param varArgs Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return The corresponding Element.\n */\nfunction elementVoid(\n    nameOrCtor: NameOrCtorDef, key?: Key, statics?: Statics,\n    ...varArgs: Array<{}>) {\n  elementOpen.apply(null, arguments);\n  return elementClose(nameOrCtor);\n}\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param value The value of the Text.\n * @param varArgs\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return The corresponding text node.\n */\nfunction text(value: string|number|boolean, ...varArgs: Array<(a: {}) => string>) {\n  if (DEBUG) {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  const node = coreText();\n  const data = getData(node);\n\n  if (data.text !== value) {\n    data.text = (value) as string;\n\n    let formatted = value;\n    for (let i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      const fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted as string;\n  }\n\n  return node;\n}\n\n\n/** */\nexport {\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementVoid,\n  elementClose,\n  text,\n  attr,\n  key,\n};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst symbols = {\n  default: '__default'\n};\n\nexport {symbols,};\n","/**\n * @fileoverview\n * @suppress {extraRequire}\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst DEBUG = true;\n\nexport {DEBUG,};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nexport type NodeFunction = (n: Node[]) => void;\n\nexport interface Notifications {\n  /**\n   * Called after patch has completed with any Nodes that have been created\n   * and added to the DOM.\n   */\n  nodesCreated: NodeFunction|null;\n  /**\n   * Called after patch has completed with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an application's responsibility to handle any childNodes.\n   */\n  nodesDeleted: NodeFunction|null;\n}\n\nexport const notifications: Notifications = {\n  nodesCreated: null,\n  nodesDeleted: null\n};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {notifications} from './notifications';\n\n\n/**\n * A context object keeps track of the state of a patch.\n */\nclass Context {\n  private created: Node[] = [];\n  private deleted: Node[] = [];\n\n  markCreated(node: Node) {\n    this.created.push(node);\n  }\n\n  markDeleted(node: Node) {\n    this.deleted.push(node);\n  }\n\n\n  /**\n   * Notifies about nodes that were created during the patch operation.\n   */\n  notifyChanges() {\n    if (notifications.nodesCreated && this.created.length > 0) {\n      notifications.nodesCreated(this.created);\n    }\n\n    if (notifications.nodesDeleted && this.deleted.length > 0) {\n      notifications.nodesDeleted(this.deleted);\n    }\n  }\n}\n\n\nexport {\n  Context,\n};\n"],"names":["map","property","hasOwnProperty","call","Blank","arr","length","pop","name","lastIndexOf","el","value","removeAttribute","attrNS","getNamespace","setAttributeNS","String","setAttribute","style","prop","indexOf","setProperty","cssText","elStyle","has","type","mutator","attributes","symbols","default","previous","inAttributes","inSkip","val","node","nodeType","root","ancestry","cur","n","push","parentNode","getRootNode","isDocumentRoot","activeElement","getActiveElement","contains","getAncestry","referenceNode","insertReferenceNode","nextSibling","next","insertBefore","nameOrCtor","key","data","NodeData","nodeName","isElement","localName","getAttribute","initData","attrsArr","i","attr","child","firstChild","tag","parent","getData","namespaceURI","doc","Function","namespace","getNamespaceForTag","createElementNS","createElement","createTextNode","argsBuilder","focusPath","focused","run","f","fn","prevContext","context","prevDoc","prevArgsBuilder","prevCurrentNode","currentNode","prevCurrentParent","currentParent","previousInAttributes","previousInSkip","Context","ownerDocument","getFocusedPath","retVal","notifyChanges","matchNode","matches","getMatchingNode","createText","markCreated","existingNode","createNode","maybeParentNode","startNode","endNode","removeChild","markDeleted","getNextNode","lastChild","statics","_i","open","staticsApplied","i_1","isNew","ATTRIBUTES_OFFSET","j","arguments","attrsStart","prevAttrsMap","_b","Object","keys","_a","undefined","getArgsBuilder","elementOpen","apply","close","elementClose","coreText","text","formatted","prototype","create","createMap","applyAttributeTyped","applyStyle","notifications","created","deleted","nodesCreated","this","nodesDeleted","Node","prev","patchInner","patchFactory","patchOuter"],"mappings":"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","sourceRoot":"/source/"}